<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>解决mysql乱码问题</title>
      <link href="/2018/06/13/%E8%A7%A3%E5%86%B3mysql%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/13/%E8%A7%A3%E5%86%B3mysql%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>默认情况下，在本地将中文插入mysql的时候,报如下的错误：<br><img src="http://mrclown.cn/屏幕快照 2018-06-13 上午10.20.34.png" alt="屏幕快照 2018-06-13 上午10.20.34"><br><a id="more"></a></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、进入到mysql的安装目录，找到my-default.cnf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/support-files</span><br></pre></td></tr></table></figure><p>2、将该文件复制到<code>/etc/</code>目录下，并命名为：my.cnf,此时该文件是只读模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./my-default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure><p>3、修改<code>my.cnf</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 766 my.cnf</span><br><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure><p>添加如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"> default-storage-engine=INNODB</span><br><span class="line"> character-set-server=utf8</span><br><span class="line"> collation-server=utf8_general_ci</span><br><span class="line">[client]</span><br><span class="line"> default-character-set=utf8</span><br></pre></td></tr></table></figure><p>定位到最后一行，将如下一句话注释掉<br><img src="http://mrclown.cn/屏幕快照 2018-06-13 上午10.41.33.png" alt="屏幕快照 2018-06-13 上午10.41.33"><br>网上的很多教程就是因为没有注释掉这一句话，所以才会导致最后的修改失败</p><p>4、最后将my.cnf文件修改为<code>只读</code>模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 744 my.cnf</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1、登陆mysql,输入status<br><img src="http://mrclown.cn/屏幕快照 2018-06-13 上午10.22.02.png" alt="屏幕快照 2018-06-13 上午10.22.02"></p><p>2、创建数据库与数据表</p><p><img src="http://mrclown.cn/屏幕快照 2018-06-13 上午10.49.47.png" alt="屏幕快照 2018-06-13 上午10.49.47"></p><p>成功！！！</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用Git操作(一)</title>
      <link href="/2018/06/04/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C-%E4%B8%80/"/>
      <url>/2018/06/04/%E5%B8%B8%E7%94%A8Git%E6%93%8D%E4%BD%9C-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file-name</span><br></pre></td></tr></table></figure><p>ps:添加某个目录下所有文件：git add /path-name/*</p><h2 id="提交刚才添加的文件"><a href="#提交刚才添加的文件" class="headerlink" title="提交刚才添加的文件"></a>提交刚才添加的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><a id="more"></a><p>##查看版本库的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="查看最近两次修改之后文件的差异"><a href="#查看最近两次修改之后文件的差异" class="headerlink" title="查看最近两次修改之后文件的差异"></a>查看最近两次修改之后文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff file-name</span><br></pre></td></tr></table></figure><h2 id="回滚到文件的某一个版本"><a href="#回滚到文件的某一个版本" class="headerlink" title="回滚到文件的某一个版本"></a>回滚到文件的某一个版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ //表示回滚到上一次的版本</span><br><span class="line">git reset --hard commit_id //commit_id 是某次提交之后的commit_id值，可以通过git log/git reflog命令组合来查看并决定回到哪个版本</span><br></pre></td></tr></table></figure><p>ps:每一次commit都会形成一个commit_id,相当于为文件建立了一个快照</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>分三种情况<br>1、只修改后没有add</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename//将工作区中的修改全部撤销</span><br></pre></td></tr></table></figure><p>2、修改之后add,即已经放到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename //吧暂存区中的修改撤销掉，重新放回工作区</span><br></pre></td></tr></table></figure><p>3、修改之后且add、commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^//直接选择回滚到上一版本</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>分两种情况<br>1、确实想删掉文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm filename//从工作区删掉</span><br><span class="line">git rm filename//从版本库删掉</span><br></pre></td></tr></table></figure><p>2、发现自己删错了，则从暂存区还原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>在本地有一个库，在github上又有一个库，想让这两个库保持同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//michaelliao换成自己的github账户</span><br><span class="line">//origin:远程库的名称</span><br><span class="line">//learngit.git是在github上建立的仓库</span><br><span class="line">git remote add origin git@github.com:michaelliao/learngit.git</span><br><span class="line">//把当前分支master推送到远程</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>ps:以上的命令行操作都是在本地创建的仓库工作区目录中执行的<br>    以后每次提交到远程就可以采取简化命令行操作<br>    git push origin master</p><h2 id="从远程克隆仓库"><a href="#从远程克隆仓库" class="headerlink" title="从远程克隆仓库"></a>从远程克隆仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone repositoryname</span><br></pre></td></tr></table></figure><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建分支dev,并切换到dev分支</span><br><span class="line">git checkout -b dev</span><br><span class="line">//查看当前分支</span><br><span class="line">git branch</span><br><span class="line">/*在当前分支dev中完成文件的修改操作之后添加，提交*/</span><br><span class="line">//切换回master分支</span><br><span class="line">git checkout master</span><br><span class="line">//将dev分支合并到master分支</span><br><span class="line">git merge dev</span><br><span class="line">//这时候dev分支还在，我们可以选择将之保留或者删掉</span><br><span class="line">git branch -d dev//删掉分支</span><br></pre></td></tr></table></figure><h2 id="冲突的产生与消除"><a href="#冲突的产生与消除" class="headerlink" title="冲突的产生与消除"></a>冲突的产生与消除</h2><p>常见问题：<br>在新的分支feature上修改之后add,commit。然后切换回master分支修改相应文件，并add,commit。<br>接着试图将feature分支合并到mater分支，这时候会出错<br>解决方法：<br>手动修改产生冲突的文件，然后继续add,commit,最后合并分支</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ul><li>github上有连个分支：master和dev分支。</li><li>从GitHub上克隆代码到本地，则本地有一个master分支，它与远程的master分支关联</li><li>创建远程origin的dev分支到本地的dev分支：git checkout -b dev origin/dev</li><li>然后就可以在本地的dev分支进行修改，并且推送到远程的origin/dev</li><li>如果另外一个人也用同样的方式将他dev的分支推送到远程的origin/dev分支，则可能会出现问题</li><li>现在本地执行:git pull</li><li>如果pull失败，则可能是由于本本地的dev没有和远程的origin/dev进行连接，执行：git branch –set-upstream-to=origin/dev dev</li><li>最后再:git pull</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将本地的master分支的代码强行推送到远程的dev分支</span><br><span class="line">git push -fu origin master:dev</span><br></pre></td></tr></table></figure><h2 id="多说几句"><a href="#多说几句" class="headerlink" title="多说几句"></a>多说几句</h2><p>现在生活中用到的git指令不是很多，基本就是git clone，所以每次<br>需要用到一些其他的git指令，就得google.干脆，将git命令一次性<br>总结好，最好能记住并且会使用啦，但是忘记了的话，每次都来到这个网站<br>查找，想来也是比较方便的。</p><p>ps:<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">参考Git教程</a></p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> bbs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《UNIX环境高级编程》学习笔记：环境配置</title>
      <link href="/2018/05/17/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/05/17/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>我的环境一开始是：<br>macOS 10.13.2,<br>gcc:7.1.0</p><h3 id="一、下载源码"><a href="#一、下载源码" class="headerlink" title="一、下载源码"></a>一、下载源码</h3><p><a href="www.apuebook,com">源码链接</a><br><a id="more"></a></p><h3 id="二、开始编译源码"><a href="#二、开始编译源码" class="headerlink" title="二、开始编译源码"></a>二、开始编译源码</h3><p>1、进入到apue.3e，输入：make<br>报错：</p><p><img src="http://mrclown.cn/15265697756775.jpg" alt=""></p><p>类似的语法错误，在某个地方需要“,”或者“；”，打开syslog.h文件，如下：</p><p><img src="http://mrclown.cn/15265699490886.jpg" alt=""></p><p>但是但是，这个文件并不能修改啊，而且是系统文件，没理由出现语法错误啊。<br>找了好久，发现这是编译器gcc的锅，这个bug已经被官方mark到网站上，<br><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82787" target="_blank" rel="noopener">见链接</a><br>大概如下：<br><img src="http://mrclown.cn/15265702882497.jpg" alt=""><br>但是并没有提供解决办法。。。只能升级gcc版本，于是在terminal输入如下命令，升级到最新版本，我的是升级到8.1.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew upgrade gcc</span><br></pre></td></tr></table></figure><p>这时候再回到apue.3e目录下，输入如下命令（因为前面已经make锅一次，但是报错了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>然后再make一下，虽然会有些警告级别的错误，但。。。问题不大。</p><h3 id="三、将相关文件复制到相关目录下"><a href="#三、将相关文件复制到相关目录下" class="headerlink" title="三、将相关文件复制到相关目录下"></a>三、将相关文件复制到相关目录下</h3><p>回到apue.3e目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、sudo cp ./include/apue.h /usr/include/</span><br><span class="line">2、sudo cp ./lib/libapue.a /usr/local/lib/</span><br><span class="line">3、sudo cp ./lib/error.c /usr/include //似乎这个文件不用复制也行</span><br></pre></td></tr></table></figure><p>网上一般的教程，在这一步是没有报错的，但是但是，我们的系统时10.13.0以后的版本，貌似并不能直接将外部的文件随意复制到一些敏感的系统目录下，报错：<code>Operation not permitted</code><br><a href="https://blog.csdn.net/z82367825/article/details/55000615" target="_blank" rel="noopener">以下是解决办法(参考链接)</a><br>1、先记下(因为等下重启电脑你会忘掉)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil disable</span><br></pre></td></tr></table></figure><p>2、重启电脑，重启的过程中一直按住 Command+R 键，打开终端，输入上述命令，即可<br>之后就可以执行复制文件的操作了</p><h3 id="四、编写书上的第一个文件，进行测试"><a href="#四、编写书上的第一个文件，进行测试" class="headerlink" title="四、编写书上的第一个文件，进行测试"></a>四、编写书上的第一个文件，进行测试</h3><p>大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;dirent.h&quot; </span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">DIR *dp;</span><br><span class="line">struct dirent *dirp;</span><br><span class="line"></span><br><span class="line">if(argc != 2) &#123;</span><br><span class="line">err_quit(&quot;usage: ls directory_name&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if((dp = opendir(argv[1])) == NULL) &#123;</span><br><span class="line">err_sys(&quot;can&apos;t open %s&quot;, argv[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while((dirp = readdir(dp)) != NULL) &#123;</span><br><span class="line">printf(&quot;%s\n&quot;, dirp-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端编译（我的是直接在sublime一个窗口写代码，一个窗口开启终端）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myls.c -o myls</span><br></pre></td></tr></table></figure><p>报错：<br><img src="http://mrclown.cn/15265718184761.jpg" alt=""><br>网上说活大概意思是缺少相关的库文件，咱们回到第三步，发现之前我们复制了一个名叫“libapue.a”的文件到/usr/local/lib目录下，看样子我们的代码需要这样的一个库文件<br>于是执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc myls.c -o myls -lapue</span><br></pre></td></tr></table></figure><p><img src="http://mrclown.cn/15265720407439.jpg" alt=""><br>嘿！没毛病。<br>在执行以下可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myls ./usr</span><br></pre></td></tr></table></figure><p><img src="http://mrclown.cn/15265721311443.jpg" alt=""></p><p>其他：gcc的一些知识<br>1、gcc filename -o newfilename -lapue<br>-lapue的意思是链接阶段需要添加libapue这个库文件<br>然而，这个库文件在哪呢？gcc在预处理阶段寻找头文件默认扫描的目录是：/usr/include/ 而库文件则是放到/usr/lib/目录下，如果相应的库文件还是没找到，则继续在/usr/local/lib目录下寻找，刚才我们将libapue.a这个文件添加到了这个目录先就是出于这个目的。<br>2、gcc -E :预编译之后停止<br>3、gcc -c : 形成.o文件，为目标文件，在这一阶段并不需要到刚才我们额外添加的那个libapue库<br>4、gcc -S：形成.s的汇编源文件</p>]]></content>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> unix/linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序初体验(一)</title>
      <link href="/2018/05/16/2018-05-16/"/>
      <url>/2018/05/16/2018-05-16/</url>
      <content type="html"><![CDATA[<p>今年参加了“互联网+”的比赛，我们的产品是一款微信小程序，作为小组里唯一的一名“技术人员”，“开发小程序”的任务义不容辞。</p><p>此前我并没有接触写过一行关于小程序的代码，仅有一点html、css、js基础。而我接到的任务是要在三天之内做出一款“演示”作用的小程序，我们是创意组，并不需要成品，当然有成品那肯定是锦上添花的啦。</p><h2 id="查看官方的简易教程"><a href="#查看官方的简易教程" class="headerlink" title="查看官方的简易教程"></a>查看官方的简易教程</h2><p>一、申请开发者ID—&gt;下载开发IDE<br>开发者ID是自动生成的一长串的字符串，看起来似乎没有没什么规律。每一次新建项目都得输入ID，除非是新建体验版的项目，所以最好新建一个文本文档，将ID保存下来，免得每次都要去到微信小程序官方网站查看。链接：<a href="https://mp.weixin.qq.com/cgi-bin/wx" target="_blank" rel="noopener">微信公众平台</a><br><a id="more"></a><br><img src="http://mrclown.cn/15264817024027.jpg" alt="-w408"></p><p>IDE的界面如下：界面风格还是很简洁、利落的。主要由模拟器，编辑器，调试器三大部分构成。由于是国内自产的一款IDE，所以界面说明大部分是中文，很适合新手啊（说的就是我）。<br><img src="http://mrclown.cn/15264817627271.jpg" alt="-w1030"></p><p>二、输出“Hello World”<br>在新建项目那一步骤里，选择“普通快速快速启动模版”就会形成官方准备的Demo.根据官方的教程，简单总结一下。<br><img src="http://mrclown.cn/15264822189377.jpg" alt="-w1018"></p><p>模拟器展现线的就是Demo的效果：只有一个简单的页面（Index）,下面则输出“Hello world”<br>文件目录：<img src="http://mrclown.cn/15264823540783.jpg" alt="-w180"><br>app.js:是整个项目中的公共逻辑处理代码部分<br>app.json:是整个项目中的配置文件<br>app.wxss:是整个项目的样式文件，可以在子项目中的*.wxss文件中覆盖该文件的设置。<br>pages目录下有index,log文件夹，分别对应的是index,log这两个界面，在小程序中，一个界面的内容用一个文件包含，一个页面文件中的文件基本组成为：</p><ul><li>文件名.js,</li><li>文件名.json,</li><li>文件名.wxml，</li><li>文件名.wxss,<br>顾名思义，根据文件的后缀则就可以知道这四个文件分别对应的是：文件的逻辑处理部分，配置部分，页面部分，样式部分。</li></ul><p>三、文件中的内容<br>app.js:每次重新启动项目都会执行一遍app.js文件中的逻辑代码，Demo中的代码解释得很清楚，这里就不解释了。<br>app.json:<br><img src="http://mrclown.cn/15264831112298.jpg" alt=""><br>很重要，每增加一个界面都要在这个文件里面进行配置，Demo中有两个界面，index和logs。window则是在配置整个项目的页面中一些公共界面。<br>app.wxml,app.wxss则表示每个页面中的一些公共页面模块和样式，可以在每个页面中进行覆盖这些设置。</p><p>注意！！！<br>在每个界面中，.js和.wxml文件是必须的！</p><p>四、一个页面的执行过程<br>在每个页面文件中对对应的.js文件中，敲下“page”再回车，既可以生成页面在程序中运行时各个状态下对应的函数<br>Data: {}这个模块中存储的是这个界面对应的数据，所有需要传到.wxml文件中的变量，都需要在这个模块中进行声明。<br>onLoad: function(){}//页面加载时初始化工作<br>onReady: function(){}//页面触发后执行的操作<br>onHide: function(){}//页面隐藏时候触发的操作<br>另外还有一些会帮我们自动生成的一些函数，比如处理下拉时刷新的函数等等。<br>另外，我们还可以在这个文件中编写处理各种事件（逻辑）的函数，只需要事先在.wxml文件对应的元素中绑定好。<br>在这个文件中常用到：this.setData（）这个函数，直接对属性进行赋值时禁止的。</p><p>五、同是界面的开发，微信小程序并没有提供类似html那样种类繁多的标签，而是提供了一些组件，是一些已经封装了很多功能的框架组件<br>1、视图容器：<br>    —- view: 常用组件，相当于html中的<div>标签<br>    —- sroll-view可以滚动的视图区域组件<br>2、基础内容组件：<br>    —- icon:展示视图界面图标<br>    —- text：展示文本内容<br>    —- progress:信息进度条<br>3、表单组件：<br>    —- button<br>    —- form<br>    —- input<br>    —- checkbox<br>    —- radio<br>    —- picker<br>    —- picker-view<br>4、互动操作组件：<br>    —- action-sheet:从手机底部弹出的可以供用户选择的选项栏<br>    —- modal:弹出对话框和用户交互<br>    —- toast:弹出提示框，仅起到提示的作用。<br>5、页面导航组件<br>    —- navigator:类似于html中<code>&lt;a&gt;</code>标签，但是微信提供了几个常用的页面间跳转的API<br>    wx.navigateTo(OBJECT):保留当前页面。跳转到应用内的某个界面<br>    wx.redirectTo(OBJECT):关闭当前的页面，跳转到应用内的某个界面<br>    wx.navigateBack()关闭当前页面，回退至前一页面<br>5、媒体组件，这个就和html中提供的媒体组件很相似了<br>    —- image<br>    —- audio<br>    —- video<br>    —- map<br>    —- canvas</div></p>]]></content>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言学习笔记（三）</title>
      <link href="/2018/05/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/05/07/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>1、预处理器：<br>C预处理器不是编译器的组成部分，但是它是编译过程的一个单独步骤，它就是一个文本的替换工具<br><a id="more"></a><br>4、预处理器运算符</p><ul><li>字符串常量化运算符<code>#</code></li><li>标记粘贴运算符<code>##</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)//在变量a,b前面添加符号#表示这是个字符串常量</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define tokenpaster(n) printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)//在n的前面添加##符号，寓意将token和n联结成一个变量</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int token34 = 40;   </span><br><span class="line">   tokenpaster(34);//输出token34 = 40</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、defined()运算符<br>用来确定一个标识符是否已经使用#defined定义过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#if !defined (MESSAGE)</span><br><span class="line">   #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Here is the message: %s\n&quot;, MESSAGE);  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、参数化的宏<br>使用这个功能来模拟函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Max between 20 and 10 is %d\n&quot;, MAX(10, 20));  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、引用C语言头文件</p><ul><li>只引用一次头文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line">the entire header file file</span><br><span class="line">#endif</span><br><span class="line">//如果HEADER_FILE已经定义，则不会再次引用文件</span><br></pre></td></tr></table></figure><ul><li>有条件的引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br><span class="line">//根据条件的判断结果来进行引用</span><br></pre></td></tr></table></figure><p>8、类型转换</p><ul><li>强制类型转换</li><li>常用的算数类型转换：隐式得把值强制转换为相同的类型，编译器首先会执行整数提升，如果操作数属性类型不同，则按照下列层次中出现的最高层次的类型<br><img src="media/15254384999099.jpg" alt=""></li></ul>]]></content>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言学习笔记一）</title>
      <link href="/2018/05/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/05/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>1、C语言数据线类型</p><ul><li>基本类型：是算术类型，包括整数类型和浮点数类型</li><li>枚举类型：也属于算数类型，被用来在程序中只能赋予一定的离散整数值的变量</li><li>void类型：类型说明符，表明没有可用的值</li><li>派生类型：指针类型，数组类型，结构类型，共用体类型和函数类型<a id="more"></a>2、C语言中的变量声明</li><li>一种是需要建立存储空间</li><li>另一种是不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 extern int a;其中变量a可以在别的文件中定义。</li></ul><p>3、C语言中的左值（lvalue）和 右值（rvalue）</p><ul><li>左值：指向内存位置的表达式称为左值表达式，左值表达式可以出现在赋值号的右边和左边</li><li>右值：存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式。</li></ul><p>4、常量：<br>常量是固定值，在程序执行期间不会改变，有叫做“字面量”</p><p>5、定义常量：</p><ul><li>#define type variable = value;</li><li>const type variable = value;<br>举例：#define char X = “x”; const String X = “hello World”</li></ul><p>6、C存储类:定义C程序中变量和函数的范围（可见性）和声明周期</p><ul><li>auto:是所有局部变量的默认存储类</li><li>register:用于定义存储在存储器中而不是RAM中的局部变量，被该类修饰的变量被访问的速度更加快速</li><li>static：指示编译器在程序的声明周期保持局部变量的存在，而不需要每次它进入或者离开作用域的时候进行销毁和创建，static是全局变量的默认存储类</li><li>extern:提供一个全局变量的引用</li></ul><p>7、数组：type arrayName[arraySize]</p><ul><li>多维数组：type name[size][size]</li><li>将数组作为参数：（ing *param）、（int param[10]）、(int param[])</li><li>从函数中返回数组：C语言不允许返回一个完整的数组作为函数的参数，但是我们可以定义一个返回数组的引用，即返回类型为指针的函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* myFunction() &#123;&#125;</span><br></pre></td></tr></table></figure><p>tips:C不支持在函数外返回局部变量的的地址，除非局部变量被修饰为static变量</p><ul><li>指向数组的指针：数组名是一个指向数组中第一个元素的常量指针。</li></ul><p>8、C指针</p><ul><li>每一个变量在内存中都有一个位置，每个位置又都定义了可以使用&amp;符号进行访问的地址，它表示的是内存中的一个地址。</li><li>指针是一个变量，其值为另一个变量的地址，即，内存中的直接位置</li><li>指针的数组：我们想让数组存储指向某种数据类型的指针</li><li>指针的指针：第一个指针包含了第二个指针的地址，第二个指针则指向了包含实际值的位置</li><li>可以将函数的参数设置为指针类型</li></ul><p>9、函数指针：指向函数的指针变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> #include &quot;stdio.h&quot;</span><br><span class="line">int max(int x, int y) &#123;</span><br><span class="line">return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//p 是函数指针</span><br><span class="line">int (* p)(int, int) = &amp;max;</span><br><span class="line">int a, b, c, d;</span><br><span class="line">printf(&quot;请输入三个数字：\n&quot;);</span><br><span class="line">scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">d = p(p(a,b), c);</span><br><span class="line">printf(&quot;最大的数字是 %d\n&quot;, d);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">//定义一个函数，参数列表中有函数指针</span><br><span class="line">void populate_array(int* array, size_t arraySize, int (*getNextValue)()) &#123;</span><br><span class="line">for (size_t i = 0; i &lt; arraySize; ++i)</span><br><span class="line">&#123;</span><br><span class="line">array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getNextRandomValue(void)&#123;</span><br><span class="line">return rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int myarray[10];</span><br><span class="line">populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, myarray[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C 语言学习笔记（二）</title>
      <link href="/2018/05/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/05/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>1、字符串，字符串实际上是使用null字符’\0’终止的一维字符数组。</p><ul><li>strcpy(s1,s2):复制字符串s2到字符串s1;</li><li>strcat(s1, s2):链接字符串s2到字符串s1的末尾</li><li>strlen(s1):返回字符串s1的长度</li><li>strcmp(s1, s2):s1如果和s2相同则返回0，s1&lt;s2则返回小于零，其他的返回大于零</li><li>strchr(s1,ch):返回一个指针，指向s1中字符第一次出现的位置</li><li>strstr(s1, s2):返回一个指针，指向字符串s1中s2第二次出现的位置。<a id="more"></a>2、结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct [struct tag] </span><br><span class="line">&#123;</span><br><span class="line">    member definition;</span><br><span class="line">    ...</span><br><span class="line">    member definition;</span><br><span class="line">&#125;[one or more struct variables];</span><br></pre></td></tr></table></figure><p>3、位域</p><blockquote><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。<br>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示</p></blockquote><p>struct 位域结构名<br>{<br>    位域列表<br>};<br>位域列表的形式为：<br>类型说明符 位域名：位长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bs&#123;</span><br><span class="line">    int a:8;</span><br><span class="line">    int b:2;</span><br><span class="line">    int c:6;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><p>tips:一个位域必须存储在同一个字节当中，所以位域的长度不能超过8位</p><p>4、共用体<br>union [union tag]<br>{<br>    member definition<br>    …<br>    member definition<br>} [one or more union variables];</p><blockquote><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式.若同一时刻多个成员同时拥有值，将会出现意想不到的错误</p></blockquote><p>5、typedef关键字：可以使用它来为类型取一个新的名字<br>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typeof struct Books</span><br><span class="line">&#123;</span><br><span class="line">    char title[50];</span><br><span class="line">    char author[50];</span><br><span class="line">    char subject[100];</span><br><span class="line">    int book_id;</span><br><span class="line">&#125; Book;//将struct Books取个新的名字为Book</span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   strcpy( book.title, &quot;C 教程&quot;);</span><br><span class="line">   strcpy( book.author, &quot;Runoob&quot;); </span><br><span class="line">   strcpy( book.subject, &quot;编程语言&quot;);</span><br><span class="line">   book.book_id = 12345;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;书标题 : %s\n&quot;, book.title);</span><br><span class="line">   printf( &quot;书作者 : %s\n&quot;, book.author);</span><br><span class="line">   printf( &quot;书类目 : %s\n&quot;, book.subject);</span><br><span class="line">   printf( &quot;书 ID : %d\n&quot;, book.book_id);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、输入输出：</p><blockquote><p>当我们谈论输入的时候，意味着要向程序填充一些数据。输入可以是以文件的形式或者从命令行中进行<br>当我们谈论输出的时候，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。</p></blockquote><p>标准文件：C语言把所有的设备都当作文件。所以设备被处理的方式与文件相同。以下的三个文件（设备）会在程序执行的时候自动打开，以便访问键盘和屏幕</p><table><thead><tr><th>标准文件</th><th>文件指针</th><th>设备</th></tr></thead><tbody><tr><td>标准输入</td><td>Stdin</td><td>键盘</td></tr><tr><td>标准输出</td><td>stdout</td><td>屏幕</td></tr><tr><td>标准错误</td><td>Stderr</td><td>您的屏幕</td></tr></tbody></table><p>文件指针是访问文件的方式。</p><ul><li>int getchar(void):从屏幕读取下一个可用的字符，并把它返回一个整数</li><li>int putchar(int c)：函数把字符输出到屏幕上，并返回相同的字符，这里的参数 c 是从上一个函数返回来的参数。</li><li>cahr<em> gets(cahr</em> s):函数从stdin读取一行到s所指向的缓冲区，直到一个终止符或者EOF</li><li>int puts(char* s):把字符串s和一个尾随的换行符写入到stdout</li><li>int scanf(const char* format …)</li><li>int printf(const char* format …)</li></ul><p>7、文件读写<br>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节</p><ul><li>FILE<em> fopen(const char</em> filename, const char* mode);//打开文件</li><li>int fclose(FILE* fp);//关闭文件</li><li>int fputc(int c, FILE* fp);//写入文件，把参数c的字符值写入到输出流中</li><li>int fputs(const char<em> s, FILE</em> fp)//把字符串s写入到fp指向的输出流中，输入成功返回一个非负值</li><li>int<em> fgets(char</em> buf, int n, FILE* fp);//从fp指向的输入流中读取n-1个字符，它会把读取到的字符串复制到缓冲区buff，并在最后一个追加null来终止字符串</li><li>int fscanf(FILE<em> fp, const char</em> format, ..);从文件中读取字符串，遇到空格会停止。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">   fprintf(fp, &quot;This is testing for fprintf...\n&quot;);</span><br><span class="line">   fputs(&quot;This is testing for fputs...\n&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   char buff[255];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);</span><br><span class="line">   fscanf(fp, &quot;%s&quot;, buff);</span><br><span class="line">   printf(&quot;1: %s\n&quot;, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;2: %s\n&quot;, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;3: %s\n&quot;, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript学习笔记</title>
      <link href="/2018/05/05/ECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/05/05/ECMAScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>1、ES中的原始值和引用值：<br>原始值：存在存在栈中，即直接存在变量访问的位置<br>引用值：存储堆中的对象，即存储变量处的是一个指针，该指针指向存储对象的内村处。<br><a id="more"></a><br>2、原始类型：即 Undefined、Null、Boolean、Number 和 String；与之相对的是引用类型，常见的有对象。</p><p>3、类型转换：<br>转换成字符串：toString()<br>转换成数字：parseInt()、parseFloat()<br>tips:从位置0开始查看每个字符，直到找到第一个非有效的数字为止，然后将前面的有效数字转换成整数</p><p>4、强制类型转换</p><ul><li>Boolean(value):将value转换成布尔类型的值</li><li>Number(value):将value转换成数字</li><li>String(value):将value转换成字符串</li></ul><p>5、String对象<br>创建：var sOtringObject = new String(“hello World”);<br>方法和属性：</p><ul><li>length</li><li>charAt(),charCodeAt();</li><li>concat():调用这个方法后的原始对象值不变</li><li>indexOf()、lastIndexOf()</li><li>localeCompare()</li><li>slice()、substring()</li></ul><p>6、instanceof（）：用于识别正在执行的对象的类型</p><p>7、delete运算符和void运算符<br>前者删除前面定一个的属性或者方法<br>后者对任何的值都是返回undefined</p><p>8、等性运算符：==、！=</p><ul><li>如果符号的两侧是对象，则比较他们的引用值，若只想同一个对象，则返回true</li></ul><p>8、全等号和非全等号：<code>===</code>、<code>!===</code><br>在比较值前不自动进行类型的转换，所以只有类型和引用值相同的时候才会返回true</p><p>9、for-in语句：<br>用于枚举对象的属性</p><p>10、标签语句:主要是为了可以使后面可以通过调用label来调用语句<br>label:statement</p><p>11、with语句：用户设置代码在特定对象中的作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var sMessage = &quot;hello&quot;;</span><br><span class="line">with(sMessage) &#123;</span><br><span class="line">    alert(toUpperCase());</span><br><span class="line">&#125;//with语句用于字符串，所以在调用toUpperCase（）方法的时候，解释程序会先查找该方法是否为本地的函数，如果不是，它将查找伪对象sMessage,看它是否为该对象的方法。</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言学习笔记（四）</title>
      <link href="/2018/05/04/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2018/05/04/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>C语言学习笔记（四）<br>1、C错误处理</p><blockquote><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p></blockquote><blockquote><p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。<br><a id="more"></a></p></blockquote><ul><li>perroe(): 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li><li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">extern int errno ;//系统宏定义有这个变量</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   int errnum;</span><br><span class="line">   pf = fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);</span><br><span class="line">   if (pf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      fprintf(stderr, &quot;错误号: %d\n&quot;, errno);</span><br><span class="line">      perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">      fprintf(stderr, &quot;打开文件错误: %s\n&quot;, strerror( errnum ));//stderr是系统提供的关于错误的文件流</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//语法格式</span><br><span class="line">void recursion()</span><br><span class="line">&#123;</span><br><span class="line">   statements;</span><br><span class="line">   ... ... ...</span><br><span class="line">   recursion(); /* 函数调用自身 */</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   recursion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int fibonaci(int i)</span><br><span class="line">&#123;</span><br><span class="line">   if(i == 0)</span><br><span class="line">   &#123;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   if(i == 1)</span><br><span class="line">   &#123;</span><br><span class="line">      return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   return fibonaci(i-1) + fibonaci(i-2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;%d\t\n&quot;, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;//斐波那契数列</span><br></pre></td></tr></table></figure><p>3、可变参数</p><ul><li>引用头文件：stdarg.h</li><li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li><li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li><li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义</li><li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li><li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"></span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"></span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、内存管理<br>管理内存的函数可以在&lt;stdlib.h&gt;头文件中找到</p><ul><li>void<em> calloc():在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num</em>size 个字节长度的内存空间，并且每个字节的值都是0</li><li>void free(void *address):该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</li><li>void malloc(int num):在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</li><li>void <em>realloc(void </em>address, int newsize):该函数重新分配内存，把内存扩展到 newsize。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"></span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"></span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;//动态分配内存</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"></span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"></span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"></span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;//重新调整内存的大小和释放内存，注意对比和动态分配内存操作进行对比</span><br></pre></td></tr></table></figure><p>5、命令行参数</p><p><code>int main(int argc, char *argv[])</code></p><ul><li>argc：指传入参数的个数</li><li>argv[]:一个指针数组，指向传递给程序的每个参数。</li><li>argv[0]记录的参数是文件的名称</li></ul>]]></content>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaScript拾遗(二)</title>
      <link href="/2018/05/04/javaScript%E6%8B%BE%E9%81%97%EF%BC%88%E4%BA%8C%EF%BC%89-1/"/>
      <url>/2018/05/04/javaScript%E6%8B%BE%E9%81%97%EF%BC%88%E4%BA%8C%EF%BC%89-1/</url>
      <content type="html"><![CDATA[<p>1、创建js对象</p><ul><li>创建直接的实例</li><li>通过函数来创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function person(firstname, lastname, age, eyecolor) &#123;</span><br><span class="line">    this.firstname=firstname;</span><br><span class="line">    this.lastname=lastname;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.eyecolor=eyecolor;</span><br><span class="line">    function changeName(name) &#123;</span><br><span class="line">        this.lastname = name;</span><br><span class="line">    &#125;</span><br><span class="line">    this.changeName = changeName;//方法也要在函数中声明和赋值</span><br><span class="line">&#125;//函数体</span><br><span class="line">//创建实例：</span><br><span class="line">var myFather = new person(&quot;Bill&quot;, &quot;Gates&quot;, 56, &quot;blue&quot;);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>2、- js的全局对象，函数以及变量均自动成为window的对象成员</p><ul><li>全局变量是window对象的属性</li><li>全局函数是window对象的方法</li></ul><p>3、查看浏览器窗口的尺寸：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var w = window.innerWidth || </span><br><span class="line">document.documentElement.clienWidth ||</span><br><span class="line"> document.body.clientWidth;</span><br><span class="line">var h=window.innerHeight</span><br><span class="line">|| document.documentElement.clientHeight</span><br><span class="line">|| document.body.clientHeight;</span><br></pre></td></tr></table></figure><p>4、window.screen:包含有关用户的屏幕信息<br>属性：<br>screen.availWidth —- 可用的屏幕宽度<br>screen.availHeight —- 可用的屏幕高度</p><p>5、window.Location:用户获取当前对象的URL,并把浏览器定向到新的页面<br>属性：<br>hostname<br>pathname<br>port<br>protocol<br>href:当前页面的整个URL<br>方法：<br>assign():加载新的文档，即可以打开新的页面</p><p>6、window.History:包含浏览器的浏览历史<br>方法：<br>back():返回前一个页面，和浏览器中后退的作用相同<br>forward():前进到页面历史列表中的一个页面</p><p>7、window.navigator：包含有关访问者浏览器的信息</p><p>8、PopupAlert：js的消息框</p><ul><li>警告框：alert(“文本”)</li><li>确认框：confirm(“文本”)</li><li>提示框：prompt(“文本”， “默认文本”)</li></ul><p>9、Timing:js计时<br>setTimeout(“js语句”，毫秒)：在一定的时间间隔之后执行js语句<br>clearTimeout(setTimeout的返回值)：取消计时器</p>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaScript拾遗（一）</title>
      <link href="/2018/05/04/javaScript%E6%8B%BE%E9%81%97(%E4%B8%80)-1/"/>
      <url>/2018/05/04/javaScript%E6%8B%BE%E9%81%97(%E4%B8%80)-1/</url>
      <content type="html"><![CDATA[<p>1、变量<br>    声明但是没有赋值的变量为：undefined</p><p>2、js的数据类型有：<br>    字符串、数字、布尔、数组、对象、Null、Undefined<br>    <a id="more"></a><br>3、创建数组的方式：</p><pre><code><figure class="highlight plain"><figcaption><span>cars </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car[0] = &quot;Audi&quot;</span><br><span class="line">...</span><br><span class="line">var vars = new Array(&quot;Audi&quot;, &quot;BMW&quot;, &quot;Volvo&quot;);</span><br></pre></td></tr></table></figure></code></pre><p>4、null、undefined<br>    可以通过将变量的值设置为null、undefined达到清空变量的目的。</p><p>5、函数：<br>   ” 是由事件驱动的或者当它被调用的时候执行的可重复使用的代码块“</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function functionName() &#123;</span><br><span class="line">     ....</span><br><span class="line">     return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、变量的生存周期：<br>    局部变量：从声明开始，到函数体的结束<br>    全部变量：从声明开始，到页面关闭</p><p>7、运算符号：<br>    <code>==</code>和<code>===</code>的异同：前者只要求值相等，后者要求类型相同，值也要相等。</p><hr><h2 id="HTML-DOM-document-object-model"><a href="#HTML-DOM-document-object-model" class="headerlink" title="HTML DOM:document object model"></a>HTML DOM:document object model</h2><p>当页面被加载的时候dom模型将会被创建</p><blockquote><p>通过可编程的对象模型，js可以创建动态的html</p><ul><li>改变页面中所有HTML元素</li><li>改变页面中所有HTML属性</li><li>改变页面中所有CSS样式</li><li>对页面中所有的事件做出响应</li></ul></blockquote><p>8、改变HTML的内容：innerHTML属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).innerHTML=newValue;</span><br></pre></td></tr></table></figure><p>9、改变HTML元素的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img id=&quot;image&quot; src=&quot;smile.gif&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;&lt;/scritp&gt;</span><br></pre></td></tr></table></figure><p>10、改变HTML样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(id).style.property=newValue</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;ps2&apos;).style.color=&quot;red&quot;;</span><br></pre></td></tr></table></figure><p>隐藏文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;p1&apos;).style.visibility=&quot;hidden&quot;</span><br></pre></td></tr></table></figure><p>显示文本则用visibility=visible;</p><p><a href="http://www.w3school.com.cn/jsref/dom_obj_style.asp" target="_blank" rel="noopener">Style对象的属性链接</a></p><hr><h3 id="HTML使js有能力对HTML事件做出反应"><a href="#HTML使js有能力对HTML事件做出反应" class="headerlink" title="HTML使js有能力对HTML事件做出反应"></a>HTML使js有能力对HTML事件做出反应</h3><blockquote><p>onclick 当用户点击时触发事件<br>onload/onunload 当用户进入或者离开页面时候触发的事件<br>onchange 当内容改变的时候触发事件<br>onmouseover/onmouseout 当鼠标移入/移出时候触发事件<br>onmousedown/onmouseup 当点击下鼠标，触发onmousedown,放松鼠标，触发onmouseup,触发顺序：onmousedown-&gt;onmouseup-&gt;onclick</p></blockquote><p>10、通过HTML DOM向HTML元素分配事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;myid&quot;).onclick=function()&#123;displayDate()&#125;;</span><br></pre></td></tr></table></figure><p>11、添加节点<br>    首先建一个新元素，然后在新元素中添加型内容（节点），最后再将创建好的元素连同创建好的节点（内容）添加到已经存在的元素中。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var para=document.createElement(&quot;p&quot;);//创建新元素</span><br><span class="line">var node=document.createTextNode(&quot;这是新段落。&quot;);//创建节点</span><br><span class="line">para.appendChild(node);//将节点添加到新创建的元素</span><br><span class="line">var element=document.getElementById(&quot;div1&quot;);</span><br><span class="line">element.appendChild(para);</span><br></pre></td></tr></table></figure></code></pre><p>12、删除已经存在的HTML元素：前提是需要知道目标元素的父元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var child = document.getElementById(&quot;p1&quot;);</span><br><span class="line">child.parentNode.removeChild(child);</span><br></pre></td></tr></table></figure><p><a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank" rel="noopener">DOM教程</a></p>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html学习笔记(二)</title>
      <link href="/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>颜色快速参考：<br><a id="more"></a><br><img src="http://mrclown.cn/15249347896003.jpg" alt=""></p><p><img src="http://mrclown.cn/15249348424456.jpg" alt=""></p><p><img src="http://mrclown.cn/15249348787840.jpg" alt=""></p><p><a href="http://www.w3school.com.cn/html/html_colornames.asp" target="_blank" rel="noopener">w3school网站颜色速查</a></p>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html学习笔记(三)</title>
      <link href="/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-1/"/>
      <url>/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-1/</url>
      <content type="html"><![CDATA[<p>input：输入</p><pre><code>- text- password- submit- radio- checkbox- buttontips:type=&quot;radio&quot;的input为单选按钮，若是佛那个多个选择中只能选一个，则多个input中必须要有相同的“name”属性值checkbox为多选按钮，但也需要多个相同的&quot;name&quot;属性值&lt;!-- more --&gt;</code></pre><p>select：下拉列表</p><figure class="highlight plain"><figcaption><span>name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    &lt;option value=&quot;Volvo&quot; selected&gt;Volvo&lt;/option&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>selected值表示默认选中</p><p>textaarea:定义多行文本输入字段</p><figure class="highlight plain"><figcaption><span>name</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the cat ...</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>button：定义可点击的按钮</p><p><code>&lt;button type=&quot;button&quot; onclick=&quot;alert(&quot;Hello World!&quot;)&quot;&gt; Cick me!&lt;/button&gt;</code></p>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html学习笔记(一)</title>
      <link href="/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2018/05/03/html%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>1、将图片作为链接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/example/html/lastpage.html&quot;&gt;</span><br><span class="line">&lt;img border=&quot;0&quot; src=&quot;/i/eg_buttonnext.gif&quot; /&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>a标签的 target 属性：<br>target=”_top”:在原窗口中打开链接；<br>target=”_blank”：在新窗口中打开链接<br><a id="more"></a><br>2、排列图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img src=&quot;#&quot; algin=&quot;bottom&quot;&gt;图片和文字的关系&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>ps:align还可以是：middle, top</p><p>3、浮动图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">&lt;img src=&quot;#&quot; align=&quot;left&quot;&gt;</span><br><span class="line">带有图像的一个段落。图像的 align 属性设置为 &quot;left&quot;。图像将浮动到文本的左侧。</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>align还可以取值：right,将图片浮动到文字的右边</p><p>4、创建图像的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;#&quot; boder=&quot;0&quot; usemap=&quot;#planetmap&quot; alt=&quot;Planets&quot; /&gt;</span><br><span class="line">&lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt;</span><br><span class="line">&lt;area shape=&quot;circle&quot; coords=&quot;180,139,14&quot; href=&quot;#&quot; target=&quot;_blank&quot; alt=&quot;Venus&quot; /&gt;</span><br><span class="line">&lt;area shape=&quot;circle&quot; coodrs=&quot;129,161, 10&quot; href=&quot;#&quot; target=&quot;_blank&quot; alt=&quot;Mercury&quot;&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>img元素中的usemap属性引用map元素的id或者name属性</p><p>5、表格：<br>跨两列的单元表格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">  &lt;th colspan=&quot;2&quot;&gt;电话&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;Bill Gates&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;555 77 854&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;555 77 855&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>跨两行的表格单元同理</p><p>6、单元表格的边距：cellpadding</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;First&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;Second&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>7、单元格的间距：cellspacing</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; cellspacing=&quot;10&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;First&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;Second&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>8、向表格添加背景颜色或者图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; bgcolor=&quot;red&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;First&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;Second&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;table border=&quot;1&quot; background=&quot;/i/eg_bg_07.gif&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;First&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;Second&lt;/td&gt;</span><br><span class="line">  &lt;td&gt;Row&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>9、表格单元的排列内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;td algin=&quot;left&quot;&gt;</span><br></pre></td></tr></table></figure><p>10、框架集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;frameset cols=&quot;25%,50%,25%&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_a.html&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_b.html&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_c.html&quot;&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>frameset与body不能同数出现在一个页面中；<br>cols的值分别表示内嵌的页面站的屏幕的比例</p><p>11、若客户的浏览器无法处理框架：添加noframe标签进行补救</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;frameset cols=&quot;25%,50%,25%&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_a.html&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_b.html&quot;&gt;</span><br><span class="line">  &lt;frame src=&quot;/example/html/frame_c.html&quot;&gt;</span><br><span class="line">&lt;noframes&gt;</span><br><span class="line">&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;</span><br><span class="line">&lt;/noframes&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>tips:可以为frame标签添加:noresize=”noresize”使得内嵌页面的大小不可通过客户进行调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;frame src=&quot;/example/html/frame_a.html&quot; noresize=&quot;noresize&quot; /&gt;</span><br></pre></td></tr></table></figure><p>内联框架：使用iframe作为链接的目标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;/example/html/demo_iframe.html&quot; name=&quot;iframe_a&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn&quot; target=&quot;iframe_a&quot;&gt;W3School.com.cn&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">tips：由于链接的目标匹配 iframe 的名称，所以链接会在 iframe 中打开。</span><br></pre></td></tr></table></figure><p>字符实体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空格：&amp;nbsp; 小于号：&amp;lt; 大于号：&amp;gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世界，你好！</title>
      <link href="/2018/05/02/the-first-article/"/>
      <url>/2018/05/02/the-first-article/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 菜鸟 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
